---
title: "02_inspect_targeted_combinations"
author: "Niklas Rindtorff"
output: 
   BiocStyle::html_document2:
    code_folding: hide
    df_print: paged
    toc_depth: 3
    toc_float: true
    fig_height: 6
    fig_width: 9.5
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=6, fig.height=4) 
# Set some global knitr options
library("knitr")
opts_chunk$set(tidy=TRUE, tidy.opts=list(blank=FALSE, width.cutoff=60), cache=TRUE, messages=FALSE)
```
#Preparation 
I load necessary packages.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(pheatmap)
library(splots)
library(patchwork)
library(synergyfinder)
library(ggsignif)
library(broom)
library(ggrepel)
library(readxl)
library(platetools)
library(PharmacoGx)
library(ggridges)
library(reshape2)

# I run a tidy and scalable version of the synergyfinder function
source("~/tas/scripts/functions/synergyfinder.R")
```

Next I load the assay data and perform direct formatting and reannotation where necessary.

```{r, warning=FALSE, message=FALSE}
##read ctg data files
ctg_data <- lapply(list.files('~/tas/data/ctg_data/combinations/', full.names=T, pattern = "1803"), 
                   function(f) read_tsv(f, col_names=F, col_types = 'cci') %>%
                     `colnames<-`(c('name', 'well', 'pcount')) %>% 
                     mutate(screen = f %>% str_split(pattern = "/") %>% unlist %>% 
                              tail(1) %>% substr(.,1,nchar(.)-4))) %>%
  bind_rows() %>%
  separate(screen, c("date", "operator", "mithras", "experiment_id"), sep = "_", remove = FALSE, extra = "merge") %>%
  #now I need to do some cleaning of badly named CTG datasets. Clara did this manually. 
  #even after manual correction there are differences in the plate annotation. I have to go over this. 
  separate(experiment_id, c("organism", "id")) %>%
  #I now join the barcode annotation data with the photon counts
  left_join(., read_excel("~/tas/data/barcodes/Organoid-Screening-Database-and-Barcodes.xlsx", 
    sheet = "Combinations") %>% drop_na() %>% 
  rename(planned_date = `Screening Date`, assay = `Image/CTG`, id = barcode) %>% 
  filter(Library != "L12")) %>%
  #I manually changed the name D007T01V036L11DM2 to D007T01V035L11DM2 to match the annotation table
  #join compound annotation data
  full_join(., lapply(list.files('~/tas/data/annotations/l11', full.names=T, pattern = "csv"), 
                   function(f) read_csv(f)) %>% bind_rows() %>%
  rename(well = destination.well) %>%
  select(drug, well, Source_Position, Source) %>%
  separate(well, c("row", "col"), sep = 1, remove = FALSE) %>%
  mutate(drug = if_else(is.na(drug), Source, drug),
         drug = if_else(well == "J19", "DMSO", drug),
         combination = if_else(col == "13", FALSE, TRUE))) %>%
  #now I perform some further conditional formatting
  #first I have to change some old names
  mutate(line = paste0(Donor, Tumor)) %>%
  rename(experiment = id) %>%
  unite(id, c("date", "line", "Library", "experiment"), remove = FALSE) %>%
  mutate(row_num = match(row, LETTERS[1:26]),
         col_num = as.numeric(col)) %>%
  #annotate concentrations, should have done it with replace()
  mutate(concentration = ifelse(Source_Position == "Rack", NA,
                                ifelse(Source_Position == "Master_Library_Plate", 1,
                                       ifelse(Source_Position == "Dilution_Plate_1", 2,
                                              ifelse(Source_Position == "Dilution_Plate_2", 3,
                                                     ifelse(Source_Position == "Dilution_Plate_3", 4,
                                                            ifelse(Source_Position == "Dilution_Plate_4", 5, "no match"))))))) %>% 
  #add further handles 
  mutate(query = substr(Library, 1, 5), 
         query_conc = substr(Library, 6, 6) %>% as.numeric()) 
```

#Inspect data
First I gain an overview of the collected data in an overview plot.  
You can see that in the first replicate we forgot to dispense DMSO controls that were not combined. 

```{r}
pdf(file = "overview_raw.pdf", width = 14, height = 3, compress = FALSE)
ctg_data %>% 
  select(id, pcount) %>% arrange(id) %>% split(., .$id) %>% lapply(., function(f) f$pcount %>% as.vector) %>%
  plotScreen(., 13, do.names = FALSE, do.legend = TRUE)
dev.off()

ctg_data %>% 
  select(id, pcount) %>% arrange(id) %>% split(., .$id) %>% lapply(., function(f) f$pcount %>% as.vector) %>%
  plotScreen(., 13, do.names = FALSE, do.legend = TRUE)
```

#Correction
##Reannotation due to errors

AS pointed out, mistankenly there were no combination-free DMSO controls in the first replicate of the screen. I therefore re-annotate the dataset.

```{r}
ctg_data<- ctg_data %>% 
  mutate(combination = ifelse(combination == FALSE & Replicate == 1, TRUE, combination))
```


##Spatial effects

Now I focus on column and row-wise effects. Row wise effects dominate clearly.

```{r}
ctg_data %>% ggplot(aes(row_num, pcount)) + geom_point() + 
  geom_smooth() +
  facet_wrap(~id, nrow = 4) + theme_bw() + ggtitle("Spatial effects of rows") 

```

```{r}
  #next figure
  ctg_data %>% ggplot(aes(col_num, pcount)) + geom_point() + 
  geom_smooth() +
  facet_wrap(~id, nrow = 4) + theme_bw() + ggtitle("Spatial effects of columns")
```

I apply a conservative row-wise loess fit for each plate

```{r}
## split data by plate and apply loess normalization
ctg_loess <- ctg_data %>% dplyr::select(row_num, col_num, pcount, id) %>% 
  # na values
  drop_na() %>%
  #set the ctrl column 13 to NA
  #mutate(pcount = ifelse(col_num == 13, NA, pcount)) %>%
  split(.$id) %>% lapply(function(s){
  ## loess fit. family is 'symmetric' to be robust to outliers
  fit <- loess(pcount ~ row_num + col_num, data=s, family='symmetric')
  ## apply normalization
  tibble(norm_fac = fit$fitted) %>% cbind(s %>% drop_na(),.) %>% 
    mutate(pcount_norm = pcount - (norm_fac - median(norm_fac)))
}) %>% bind_rows() %>% full_join(ctg_data)
```

Now I plot the results for rows and columns

```{r}
ctg_loess %>% ggplot(aes(row_num, pcount_norm)) + geom_point() + 
  geom_smooth() +
  facet_wrap(~id, nrow = 4) + theme_bw() + ggtitle("Spatial effects of rows") 

```

```{r}
  #next figure
  ctg_loess %>% ggplot(aes(col_num, pcount_norm)) + geom_point() + 
  geom_smooth() +
  facet_wrap(~id, nrow = 4) + theme_bw() + ggtitle("Spatial effects of columns")
```

Again I plot the overview map for all plates. I think I have been able to reduce spatial effects.

```{r}
pdf(file = "overview_norm.pdf", width = 14, height = 3, compress = FALSE)
ctg_loess %>% 
  select(id, pcount_norm) %>% arrange(id) %>% split(., .$id) %>% lapply(., function(f) f$pcount %>% as.vector) %>%
  plotScreen(., 13, do.names = FALSE, do.legend = TRUE)
dev.off()

ctg_loess %>% 
  select(id, pcount_norm) %>% arrange(id) %>% split(., .$id) %>% lapply(., function(f) f$pcount %>% as.vector) %>%
  plotScreen(., 13, do.names = FALSE, do.legend = TRUE)
```

#QC

Now I look at the distribution of controls in the first screening replicate.

```{r, warning=FALSE}
coi <- c("Stauro_500nM", "DMSO")

ctg_loess %>%
  mutate(line_date_exp = paste0(line, "_", date)) %>%
  filter(drug %in% coi) %>%
  ggplot(aes(drug, pcount_norm, color = combination)) +
  #geom_violin(aes(group = drug)) +
  #geom_jitter(alpha = 0.7) +
  geom_boxplot(width = 30) +
  facet_grid(line_date_exp ~ Library) +
  theme_bw()

# ctg_loess %>%
#   mutate(line_date_exp = paste0(line, "_", date)) %>%
#   filter(drug %in% coi) %>%
#   filter(combination == TRUE) %>%
#   ggplot(aes(id, pcount_norm, color = drug)) +
#   #geom_violin(aes(group = drug)) +
#   geom_boxplot(alpha = 0.7) + 
#   #facet_grid(line_date_exp ~ Library) + 
#   #facet_wrap(~line) +
#   theme_classic()
```

For the second timepoint I was able to calculate z-factors. They seem robust for all plates.

```{r, eval = TRUE}
z_df <- ctg_loess %>%
  filter(drug %in% coi) %>%
  group_by(id, drug, combination, Library, line, date, experiment) %>%
  summarise(sd = sd(pcount_norm, na.rm = TRUE),
            mean = mean(pcount_norm, na.rm = TRUE)) %>%
  group_by(id, combination, Library, line, date, experiment) %>%
  summarise(zfactor = 1-((3*sum(sd))/abs(range(mean)[1]-range(mean)[2]))) %>%
  mutate(qc = if_else(zfactor < 0.25, FALSE, TRUE))

z_df %>% 
  mutate(query = substr(Library, 1, 5), 
         query_conc = substr(Library, 6, 6)) %>%
  filter(combination != TRUE) %>%
  arrange(zfactor) %>%
  ungroup() %>%
  mutate(id = factor(id, levels = id)) %>%
  ggplot(aes(zfactor, id)) + 
  geom_point(aes(color = query, shape = line, size = query_conc)) + 
  theme_classic()

# z_df_anno <- z_df %>% ungroup%>% mutate(id = paste0(id, "_", combination)) %>% 
#   dplyr::select(-experiment, -zfactor) %>%
#   as.data.frame() %>% 
#   remove_rownames() %>%
#   column_to_rownames("id")
# 
# z_df %>% ungroup%>% mutate(id = paste0(id, "_", combination)) %>% dplyr::select(id, zfactor) %>% 
#   arrange(zfactor) %>%
#   as.data.frame() %>% 
#   remove_rownames() %>%
#   column_to_rownames("id") %>% 
#   pheatmap(., cluster_cols = FALSE, annotation_row =  z_df_anno)
```

Now I create a correlation plot for both replicates across all plates except the column 13 combination wells. 

```{r}
r <- ctg_loess %>%
  filter(col_num != 13) %>% 
  mutate(ctrl = ifelse(drug == "DMSO", "negative", "none")) %>% 
  mutate(ctrl = ifelse(drug == "Stauro_500nM", "positive", ctrl)) %>% 
  #filter(drug %in% coi) %>%
  dplyr::select(line, Library, date, pcount_norm, well, ctrl) %>% 
  unite(id, c("line", "Library", "well")) %>%
  spread(date, pcount_norm) %>% 
  rename(rep1 = `180320`) %>%
  rename(rep2 = `180327`) %>%
  dplyr::select(rep1, rep2) %>% 
  as.matrix() %>%
  cor() %>%
  .["rep1", "rep2"]

ctg_loess %>%
  filter(col_num != 13) %>% 
  mutate(ctrl = ifelse(drug == "DMSO", "negative", "none")) %>% 
  mutate(ctrl = ifelse(drug == "Stauro_500nM", "positive", ctrl)) %>% 
  #filter(drug %in% coi) %>%
  dplyr::select(line, Library, date, pcount_norm, well, ctrl) %>% 
  unite(id, c("line", "Library", "well")) %>%
  spread(date, pcount_norm) %>% 
  rename(rep1 = `180320`) %>%
  rename(rep2 = `180327`) %>%
  ggplot(aes(rep1, rep2)) + 
  geom_point(alpha = 0.2) +
  #geom_point(alpha = 0.2, aes(color = ctrl)) + 
  #scale_color_manual(values=c("#E69F00", "#999999", "#56B4E9")) +
  geom_abline(intercept = 0, slope = 1) +
  theme_classic() + 
  ggtitle(paste0("r (pearson) = ", r %>% round(2))) + 
  xlab("replicate 1") + 
  ylab("replicate 2") + 
  scale_y_continuous(breaks = c(0, 250000, 500000, 750000)) + 
  coord_fixed() + 
  ggsave("pearson_raw.pdf", width = 4, height = 4)
  
  
```


#Normalization 
##Adapting replicate 1 

I go through the control viabilities once more. I only have non-combined DMSO controlls in the second replciate. To normalize every plate to a relative viability I will have to infer the unperturbed DMSO viability for the second replicate. First I check how robust the second replicate is.
 
```{r}
coi <- c("DMSO", "Stauro_500nM")

ctg_loess %>%
  filter(drug %in% coi & combination == FALSE) %>%
  ggplot(aes(Library, pcount_norm)) +
  geom_boxplot(aes(colour = drug), width =1, position = "identity") + 
  theme_bw() + 
  facet_grid(line~date) +
  #scale_y_continuous(limits = c(-1,250000)) +
  ggtitle("Before DMSO normalization") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

I prepare a publication style figure for the raw photon counts of uncombined controls

```{r}
coi <- c("DMSO", "Stauro_500nM")

ctg_loess %>%
  filter(drug %in% coi & combination == FALSE) %>%
  ggplot(aes(id, pcount_norm)) +
  geom_boxplot(aes(colour = drug), width =1, position = "identity") + 
  theme_classic() + 
  #facet_grid(line~date) +
  #scale_y_continuous(limits = c(-1,250000)) +
  #ggtitle("Before DMSO normalization") + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank()) +
  scale_color_manual(values=rev(c("#999999", "#000000"))) +
  ylab("Photon count") +
  ggsave("ctrls_raw_byplate_uncombined.pdf", width = 6, height = 4)
  
  # cor(use = "complete.obs")
  # pheatmap()
```

Given the fairly robust performance of the second replicate I now check how well the perturbed DMSO controls correlate between the two replicates. 

```{r}
coi <- c("DMSO", "Stauro_500nM")

ctg_loess %>%
  filter(combination == TRUE) %>% 
  #filter(drug %in% coi) %>%
  dplyr::select(line, Library, date, pcount_norm, well) %>% 
  unite(id, c("line", "Library", "date")) %>%
  spread(id, pcount_norm) %>% 
  dplyr::select(-well) %>% 
  corrr::correlate() %>%
  corrr::stretch() %>% 
  mutate(id = substr(x, 1,14) %>% sub("_$","",.)) %>% 
  rowwise() %>%
  mutate(pair = grepl(y, pattern = id)) %>% 
  filter(pair == TRUE) %>% 
  drop_na() %>% 
  distinct(r, id) %>% 
  arrange(desc(r)) %>% 
  mutate(id = factor(id, levels = id)) %>%
  ggplot(aes(id, r)) + 
  geom_bar(stat = "identity") + 
  theme_classic() + 
  geom_hline(yintercept = 0.75) + 
  ylab("Pearson correlation") +
  scale_y_continuous(limits = c(0,1)) +
  #coord_fixed() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        axis.title.x = element_blank()) + 
  ggsave("pearson_raw_byplate.pdf", width = 4, height = 4) 
  # cor(use = "complete.obs")
  # pheatmap()
```

The NA1/2 treatments show a horrible correlation because there are no viable cells on these plates. The rest of all plates seem to correlate well. 
As the pearson correlation is scale-invariant I now compare the distributions of all plate pairs.

```{r}
ctg_loess %>%
    filter(combination == TRUE) %>%
    mutate(line_date_exp = paste0(line, "_", date)) %>%
    ggplot(aes(date, pcount_norm)) +
    geom_violin(aes(group = date,  color = date)) + 
    #geom_jitter(alpha = 0.7) +
    geom_boxplot(data = ctg_loess %>% filter(combination == TRUE, drug == "DMSO"), aes(group = date), width = 1) +
    facet_grid(line ~ Library) +
    theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
    ggsave("violin_raw_byplate.pdf", width = 10, height = 4) 
```

The Trametinib treated plates seem highly related. The other plates need some batch correction.
To be sure I calculate the eucledian distance between each replicate. I do not plot these results.

```{r, eval = FALSE}
coi <- c("DMSO", "Stauro_500nM")

ctg_loess %>%
  filter(combination == TRUE) %>% 
  #filter(drug %in% coi) %>%
  dplyr::select(line, Library, date, pcount_norm, well) %>% 
  unite(id, c("line", "Library", "date")) %>%
  spread(id, pcount_norm) %>% 
  dplyr::select(-well) %>% as.matrix() %>% t() %>% dist() %>% tidy() %>%
  mutate(id = substr(item1, 1,14)) %>% 
  rowwise() %>%
  mutate(pair = grepl(item2, pattern = id)) %>% 
  filter(pair == TRUE) %>% 
  drop_na() %>% 
  distinct(distance, id) %>% 
  arrange(desc(distance)) %>% 
  mutate(id = factor(id, levels = id)) %>%
  ggplot(aes(id, distance)) + 
  geom_point() + 
  theme_classic() + 
  
  #geom_hline(yintercept = 0.75) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

Next I will remove the NA2 treatments of line D027T01 for consistency and extrapolate the untreated DMSO viability of the second replicate onto the first for all plates. 

```{r}
ctg_ln <- ctg_loess %>%
  #mutate(line_date_exp = paste0(line, "_", date)) %>%
  dplyr::filter(!(Library == "L11NA2" & Donor == "D027")) %>% 
  #dplyr::filter(query != "L11NA" ) %>% #In case I want to remove the whole Napabucasin group
  left_join(ctg_loess %>% filter(drug == "DMSO", combination == TRUE) %>% group_by(id) %>% summarise(dmso_combi_id = median(pcount_norm))) %>% 
  left_join(ctg_loess %>% filter(drug == "DMSO", combination == FALSE) %>% group_by(id) %>% summarise(dmso_solo_id = median(pcount_norm))) %>%
  #the Stauro ID is not 100% useful right now
  left_join(ctg_loess %>% filter(drug == "Stauro_500nM") %>% group_by(id) %>% summarise(stauro_id = median(pcount_norm))) %>%
  #Now I calculate the ration between treated and untreated DMSO control based on the second replicate
  mutate(dmso_ratio = dmso_combi_id/dmso_solo_id) 

ctg_ln <- ctg_ln %>% 
  #Now I transfer the dmso_ratio to all plates of the first replicate
  left_join(., ctg_ln %>% group_by(query, query_conc, line) %>% summarise(dmso_ratio_all = median(dmso_ratio, na.rm = TRUE))) %>% dplyr::select(-dmso_ratio) %>% rename(dmso_ratio = dmso_ratio_all) %>%
  # I calibrate all batches by their combined DMSO treatment
  mutate(dmso_solo_id = ifelse(date == "180320", dmso_combi_id / dmso_ratio, dmso_solo_id)) %>% 
  mutate(viability = pcount_norm/dmso_solo_id) %>% 
  #I crop the minimal viability to be zero
  mutate(viability_uncropped = viability) %>% 
  mutate(viability = if_else(viability < 0, 0, viability))
```

Now I run a quick sanity check to see if the dmso ratio appears consistent

```{r}
ctg_ln %>% distinct(query, line, query_conc, date, dmso_ratio, dmso_solo_id) %>% ggplot(aes(query_conc, dmso_ratio)) + geom_point(aes(color = query, shape = line)) + theme_classic() + facet_wrap(~date) 

```

Just to be sure I check that there is a difference in between biological replicates for the semi-inferred solo-dmso control

```{r}
ctg_ln %>%
    filter(combination == TRUE) %>%
    mutate(line_date_exp = paste0(line, "_", date)) %>%
    ggplot(aes(date, dmso_solo_id)) + 
  geom_point() + 
  facet_grid(line ~ Library) +
    theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

# Repeating diagnostic plots
Now I repeat the violin plot with normalized viabilities

```{r}
ctg_ln %>%
    filter(combination == TRUE) %>%
    mutate(line_date_exp = paste0(line, "_", date)) %>%
    ggplot(aes(date, viability)) +
    geom_violin(aes(group = date,  fill = date)) + 
    #geom_jitter(alpha = 0.7) +
    geom_boxplot(data = ctg_ln %>% filter(combination == TRUE, drug == "DMSO"), aes(group = date), width = .8, alpha = 0.7) +
  scale_fill_manual(values = c("#A9A9A9", "#D3D3D3")) +
    facet_grid(line ~ Library) +
    theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  ggsave("violin_norm_byplate.pdf", width = 8, height = 4) 
```

Finally I plot the overall and partial correlation of processed viabilites

```{r}
ctg_ln %>%
  filter(combination == TRUE) %>% 
  #filter(drug %in% coi) %>%
  dplyr::select(line, Library, date, viability, well) %>% 
  unite(id, c("line", "Library", "date")) %>%
  spread(id, viability) %>% 
  dplyr::select(-well) %>% 
  corrr::correlate() %>%
  corrr::stretch() %>% 
  mutate(id = substr(x, 1,14) %>% sub("_$","",.)) %>% 
  rowwise() %>%
  mutate(pair = grepl(y, pattern = id)) %>% 
  filter(pair == TRUE) %>% 
  drop_na() %>% 
  distinct(r, id) %>% 
  arrange(desc(r)) %>% 
  mutate(id = factor(id, levels = id)) %>%
  ggplot(aes(id, r)) + 
  geom_bar(stat = "identity") + 
  theme_classic() + 
  geom_hline(yintercept = 0.75) + 
  ylab("Pearson correlation") +
  scale_y_continuous(limits = c(0,1)) +
  #coord_fixed() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        axis.title.x = element_blank()) + 
  ggsave("pearson_norm_byplate.pdf", width = 4, height = 4) 
  # cor(use = "complete.obs")
  # pheatmap()
```

And overall correlation

```{r}
r <- ctg_ln %>%
  filter(col_num != 13) %>% 
  mutate(ctrl = ifelse(drug == "DMSO", "negative", "none")) %>% 
  mutate(ctrl = ifelse(drug == "Stauro_500nM", "positive", ctrl)) %>% 
  #filter(drug %in% coi) %>%
  dplyr::select(line, Library, date, viability, well, ctrl) %>% 
  unite(id, c("line", "Library", "well")) %>%
  spread(date, viability) %>% 
  rename(rep1 = `180320`) %>%
  rename(rep2 = `180327`) %>%
  dplyr::select(rep1, rep2) %>% 
  as.matrix() %>%
  cor() %>%
  .["rep1", "rep2"]

ctg_ln %>%
  filter(col_num != 13) %>% 
  mutate(ctrl = ifelse(drug == "DMSO", "negative", "none")) %>% 
  mutate(ctrl = ifelse(drug == "Stauro_500nM", "positive", ctrl)) %>% 
  #filter(drug %in% coi) %>%
  dplyr::select(line, Library, date, viability, well, ctrl) %>% 
  unite(id, c("line", "Library", "well")) %>%
  spread(date, viability) %>% 
  rename(rep1 = `180320`) %>%
  rename(rep2 = `180327`) %>%
  ggplot(aes(rep1, rep2)) + 
  geom_point(alpha = 0.2) +
  #geom_point(alpha = 0.2, aes(color = ctrl)) + 
  #scale_color_manual(values=c("#E69F00", "#999999", "#56B4E9")) +
  geom_abline(intercept = 0, slope = 1) +
  theme_classic() + 
  ggtitle(paste0("r (pearson) = ", r %>% round(2))) + 
  xlab("replicate 1") + 
  ylab("replicate 2") + 
  scale_y_continuous(breaks = c(0, 0.5, 1, 1.5)) + 
  geom_hline(yintercept = 1) + 
  geom_vline(xintercept = 1) +
  coord_fixed() + 
  ggsave("pearson_norm.pdf", width = 4, height = 4)
```

As well as the example plots for repoducibility

```{r}
coi <- c("DMSO", "Stauro_500nM")

ctg_ln %>%
  filter(drug %in% coi & combination == FALSE) %>%
  ggplot(aes(id, viability)) +
  geom_boxplot(aes(colour = drug), width =1, position = "identity") + 
  theme_classic() + 
  #facet_grid(line~date) +
  #scale_y_continuous(limits = c(-1,250000)) +
  #ggtitle("Before DMSO normalization") + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank()) +
  scale_color_manual(values=rev(c("#999999", "#000000"))) +
  ylab("Photon count") +
  ggsave("ctrls_norm_byplate_uncombined.pdf", width = 6, height = 4)
```

#Calculating synergy scores
I consider using the "synergyfinder" package, published by He et al. at the FIMM. 
First I have to wrangle the data into a standardized input format. This is an ugly peace of code. 

```{r, warning=FALSE, message=FALSE}
controls <- c("Stauro_500nM")
df <- ctg_ln
#not a universal function
syn_table <- df %>%
  filter(!drug %in% controls & combination == TRUE) %>%
  #filter(query != "L11DM") %>%
  #filter(combination == TRUE) %>%
  rename(rv = viability) %>%
  #setup the easy stuff
  dplyr::transmute(
    BlockID = paste(query, drug, sep = "_"),
         Response = rv*100,
         Replicate = ifelse(date == "180320", 1, 2),
         DrugRow = query,
         DrugCol = drug,
         #build matrix
         Col = ifelse(drug != "DMSO", as.numeric(concentration), 6),
         Row = ifelse(is.na(query_conc), 5, as.numeric(query_conc)),
         #define concentrations
         ConcRow = ifelse(is.na(query_conc), 0, 25/(5^(as.numeric(query_conc)-1))), #assuming the initila concentration is 50
         ConcCol = 10/(5^(as.numeric(concentration)-1)),
         ConcUnit = "uM",
    line = line
         ) #%>% mutate(BlockID = paste(query, drug, sep = "_"))

#Next I add the DMSO controls for the query drug concentrations
syn_table <- full_join(syn_table %>% filter(DrugCol != "DMSO"), 
                      syn_table %>% filter(DrugCol == "DMSO") %>% 
                      select(-BlockID) %>% 
                        group_by(DrugRow, Row, Replicate, line, DrugCol, Col, ConcRow, ConcCol, ConcUnit) %>% 
                        summarise(Response = mean(Response, na.rm = TRUE))  %>% 
  do(cbind(., BlockID = paste(.$DrugRow, syn_table %>% filter(DrugCol != "DMSO") %>% .$DrugCol %>% unique, sep = "_"))))

#Now I add the DMSO controls for the individual drug tested
syn_table <- full_join(syn_table %>% filter(DrugRow != "L11DM"), 
                      syn_table %>% filter(DrugRow == "L11DM") %>% 
  select(-BlockID) %>% group_by(DrugCol, Col, Replicate, line) %>% 
  do(cbind(., BlockID = paste(syn_table %>% filter(DrugRow != "L11DM") %>% .$DrugRow %>% unique, .$DrugCol, sep = "_"))))
 
#Finally I add the last missing piece, the DMSO ~ DMSO control fields
syn_table <- full_join(syn_table,
                      syn_table %>% filter(DrugCol == "DMSO", DrugRow == "L11DM") %>% select(-BlockID) %>% distinct() %>% 
  group_by(DrugCol, Col, Replicate, line) %>% 
  do(cbind(., BlockID = syn_table %>% filter(!grepl(BlockID, pattern = "DMSO")) %>% .$BlockID %>% unique ))) %>% mutate(ConcCol = if_else(DrugCol == "DMSO", 0, ConcCol))
```

Now having this wrangled dataframe and an own function in place, I calculate synergies. 

```{r, warning=FALSE, message=FALSE, eval = FALSE}
syn_scores <- syn_table %>%  group_by(line, Replicate , BlockID) %>% 
  do(tidy_synergy(df = ., me = c("ZIP", "HSA", "Bliss", "Loewe"))) %>%
  ungroup() %>%
  #complete the df for scores that could not be calculated
  mutate(method = as.factor(method),
         line = as.factor(line)) %>% 
  complete(BlockID, method, Replicate, line) %>%
  mutate(score_average = ifelse(is.nan(score_average), NA, score_average))


save(syn_scores, file = "syn_scores_targeted_complete.Rdata")
```

##Identify causes of failed synergy calculations
I receive a lot of error messages during synergy calculations. First I identify where these errors occur.

```{r}
load("syn_scores_targeted_complete.Rdata")

syn_errors <- syn_scores %>% 
  separate(BlockID, c("query", "drug"), remove = FALSE, sep = "_") %>%
  mutate(na = is.na(score_average)) 

percent_error = syn_errors %>%
  summarise(t = sum(na),
            n = n()) %>% 
  mutate(perc_ratio = t/n*100)

syn_errors%>%
  group_by(method, Replicate, line) %>% 
  summarise(t = sum(na),
            n = n()) %>% 
  mutate(perc_ratio = t/n*100) %>% 
  ggplot(aes(method, perc_ratio)) + geom_bar(stat = "identity") + facet_grid(Replicate ~ line) + theme_bw()

```

It does not seem to be an overall issue of synergy calculation methodology and replicate. Rather, there seem to be line/treatment specific effects

```{r}
syn_errors %>% 
  group_by( line, query) %>% 
  summarise(t = sum(na),
            n = n()) %>% 
  mutate(perc_ratio = t/n*100) %>% 
  ggplot(aes(query, perc_ratio)) + geom_bar(stat = "identity") + facet_wrap(~ line) + theme_bw()
```

First, there seems to be a query effect. L11EV causes an enorumous amount of errors during synergy calculations.  
Next I check if there are certain drugs that drive failures in synergy scoring more than can be explained by L11EV problems alone. 

```{r}
threshold = 25

syn_errors_drug <- syn_errors %>% 
  group_by( drug) %>% 
  summarise(t = sum(na),
            n = n()) %>% 
  mutate(perc_ratio = t/n*100) %>% 
  mutate(label = perc_ratio > threshold)

syn_errors_drug %>% ggplot(aes(reorder(drug, -perc_ratio), perc_ratio, label = drug)) + geom_point() +theme_classic() + 
  theme(
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) + 
  ggrepel::geom_text_repel(data = syn_errors_drug %>% filter(label == TRUE)) + 
  geom_hline(yintercept = threshold)

drug_errors <- syn_errors_drug %>% filter(label == TRUE) %>% dplyr::select(-t, -n) %>% .$drug
```

Second, selected drugs seem to fail repeatedly. I plot the dose response curves of these drugs to understand the issue at hand.

###Query effects 

I wonder what causes L11EV to fail for line D027T01. Therefore I compare overall dose-response curves for both lines.

```{r}
syn_table %>% filter(DrugCol == "DMSO") %>% select(-BlockID) %>% distinct() %>% 
  filter(DrugRow != "L11DM") %>%
  ggplot(aes(ConcRow, Response, group = Replicate)) + 
  geom_point() + 
  geom_path() +
  scale_x_log10() + 
  theme_bw() + 
  facet_grid(DrugRow ~ line)
```

I see that Everolimus has almost no dose-response effects.

###Drug effects

The same lack of dose-response can be seen for the failing drugs.

```{r}
syn_table %>% filter(DrugCol %in% drug_errors) %>% select(-BlockID) %>% distinct() %>% 
  filter(DrugRow == "L11DM") %>%
  ggplot(aes(ConcCol, Response, group = Replicate)) + 
  geom_point() + 
  geom_path() +
  scale_x_log10() + 
  theme_bw() + 
  facet_grid(DrugCol ~ line)
  #facet_wrap( ~ line)
```

#Calculate AUC of drug responses

Both for further understanding the convergence failures and finding alternatives to synergy calculation, I calculate the AUC of every perturbation.

```{r, warning=FALSE, message=FALSE, eval = FALSE}
auc_syn <- ctg_ln%>%
  #filter(Library == "L11DM") %>%
  as.tibble() %>%
  mutate(pc_norm = viability) %>%
  rename(rack.concentration = concentration) %>% 
  filter(!drug %in% c("Stauro_500nM", "DMSO")) %>% 
  unite(drug, Library, drug, remove = FALSE) %>% #overwriting variable name for ease of use
  #filter(drug == coi) %>%
  group_by(screen, drug) %>% arrange(rack.concentration) %>%
  ## calculate auc both for fitted curve and actual values
  mutate(s_AUC_fit = computeAUC(rack.concentration, pc_norm, verbose=T,
                              viability_as_pct = F, area.type = 'Fitted'),
         s_AUC_actual = computeAUC(rack.concentration, pc_norm, verbose=T,
                                 viability_as_pct = F, area.type='Actual')) %>%
  group_by(line, drug) %>% arrange(rack.concentration) %>%
  ## calculate auc both for fitted curve and actual values
  mutate(l_AUC_fit = computeAUC(rack.concentration, pc_norm, verbose=F,
                              viability_as_pct = F, area.type = 'Fitted'),
         l_AUC_actual = computeAUC(rack.concentration, pc_norm, verbose=F,
                                 viability_as_pct = F, area.type='Actual')) %>%
  ungroup()

save(auc_syn, file = "auc_syn_0518.Rdata")
```

The calculated AUCs correlate very strong irrespective of mode of calculation. 
Therefore I will go with with a line-wise unfitted AUC. 

```{r}
load("auc_syn_0518.Rdata")

auc_syn %>% as.tibble() %>% 
  filter(!(grepl(pattern = "L11DM", drug) & rack.concentration != 1)) %>%
  dplyr::select(drug, rack.concentration, 39:42, line, date) %>% distinct() %>%
  tidyr::unite(id, drug, rack.concentration, line, date, sep = "_") %>% 
    as.data.frame() %>% 
    column_to_rownames("id") %>%
  corrr::correlate()
```

Plotting the density curves of calculated AUCs it becomes apparent how all drugs which failed more than `r threshold` percent of the time show a very small AUC.

```{r, eval = FALSE}
auc_syn %>% as.tibble() %>% 
  dplyr::select(drug, rack.concentration, l_AUC_actual, line) %>% distinct() %>% 
  separate(drug, c("library", "drug"), sep = "_") %>% 
  filter(library == "L11DM") %>% 
  left_join(syn_errors_drug) %>% 
  ggplot(aes(l_AUC_actual, stat(count), fill = label))+
  #geom_histogram(bins = 45) + 
  geom_density(alpha = 0.7) +
  theme_classic()
```

In summary, using curve fitting to describe synergy only works well when there is some degree of dyanmics in the dose-response relationship (the 1-AUC is not close to 0).
We therefore loose `r percent_error$perc_ratio` percent of the initial data when sticking to this strategy. 

#Alternative Synergy scoring
##pi-scoring 

I currenlty think of using something like a pi-score, too. 
First I check the dirstribution of photon counts

```{r}
ctg_ln %>% 
  ggplot(aes(viability, stat(count), fill = line))+
  #geom_histogram(bins = 45) + 
  geom_density(alpha = 0.7) +
  theme_classic()
```

The normalized photon counts are not normally distributed. I transform the data using a glog. It is no perfect result 

```{r}
ctg_ln %>% 
  mutate(via = viability) %>%
  mutate(gl_via = FitAR::glog(via)) %>% 
  #mutate(gl_via = FitAR::glog(gl_via)) %>%
  mutate(l_via = log(1-viability)) %>%
  #mutate(ath_via = atanh(viability)) %>% 
  ggplot(aes(via, stat(count), fill = line))+
  #geom_histogram(bins = 45) + 
  geom_density(alpha = 0.7, show.legend = FALSE) +
  theme_classic() + 
  
ctg_ln %>% 
  mutate(via = viability) %>%
  mutate(gl_via = FitAR::glog(via)) %>% 
  mutate(il_via = car::logit(via)) %>% #not sure if allowed given that I accept values > 1
  mutate(l_via = log(1-viability)) %>%
  #mutate(ath_via = atanh(viability)) %>% 
  ggplot(aes(gl_via, stat(count), fill = line))+
  #geom_histogram(bins = 45) + 
  geom_density(alpha = 0.7) +
  theme_classic()
```

Now I calulate pi scores and use the eBayes function to derive p-values.

```{r}
#input df with viability effects
a <-ctg_ln %>% 
  filter(combination == TRUE) %>% 
  filter(!drug %in% c("Stauro_500nM", "DMSO")) %>%
  mutate(via = viability) %>%
  mutate(gl_via = FitAR::glog(via)) %>% 
  #mutate(il_via = car::logit(via)) %>% 
  mutate(gl_via_z = (gl_via - median(gl_via))/mad(gl_via)) %>% #not sure if allowed given that I accept values > 1
  unite(drug, drug, concentration) %>% 
  unite(id, line, date, Library) %>% 
  dplyr::select(gl_via_z, drug, id) %>%
  spread(id, gl_via_z) %>% 
  as.data.frame() %>% 
  column_to_rownames("drug")

#apply medpolish
b <- medpolish(a)

b$residuals %>% pheatmap::pheatmap(show_rownames = FALSE)

#calculate pi scores
c <- b$residuals %>% melt() %>% 
  separate(Var2, c("rep", "date", "query"), sep = "_") %>% 
  unite(rep, rep, date) %>%
  rename(target = Var1) %>% as.tibble() %>% 
  spread(rep, value)

p <- limma::ebayes(limma::lmFit(c[,-c(1,2)]))

d <- c %>% cbind(p$p.value) %>% 
  rename(p.val = x1) %>% 
  mutate(fdr = p.adjust(p.val, method = "BH"))

pi_df <- c %>% dplyr::select(1,2) %>% 
  left_join(tibble(target = names(b$row),
       target_main = b$row %>% as.numeric())) %>% 
  
  left_join(tibble(query = names(b$col),
       query_main = b$col %>% as.numeric()) %>% 
         separate(query, c("rep", "date", "query"), sep = "_") %>% 
         unite(rep, rep, date)) %>%
  
  left_join(b$residuals %>% melt() %>% 
  separate(Var2, c("rep", "date", "query"), sep = "_") %>% 
  unite(rep, rep, date) %>%
  rename(target = Var1,
         pi = value)) %>% 
  
  left_join(d[,-c(3:6)]) %>% 
  
  left_join(ctg_ln %>% 
    filter(combination == TRUE) %>% 
    filter(!drug %in% c("Stauro_500nM", "DMSO")) %>%
    mutate(via = viability) %>%
    mutate(gl_via = FitAR::glog(via)) %>% 
    #mutate(il_via = car::logit(via)) %>% 
    mutate(measured = (gl_via - median(gl_via))/mad(gl_via)) %>% #not sure if allowed given that I accept values > 1
    unite(target, drug, concentration) %>% 
    unite(rep, line, date) %>% 
    group_by(target, rep) %>% 
      summarise(measured = mean(measured)) %>%
      distinct()) %>% 
  
  mutate(expected = target_main + query_main) %>%
  arrange(fdr)
  


pi_df %>% View 
pi_df$p.val %>% hist()
pi_df$fdr %>% hist()
```

It turns out this approach did not deliver results that overlap with established methods of synergy calculation. For now I leave it as is.

```{r}
pi_df %>% 
  separate(target, c("drug", "drug_conc"), sep = "_") %>% 
  mutate(query = substr(query, 1, 5)) %>%
  unite(BlockID, query, drug) %>% 
  separate(rep, c("line", "date"), sep = "_") %>% #unnecessary
  mutate(Replicate = if_else(date == 180327, 1, 2)) %>%
  dplyr::select(BlockID, Replicate, line, pi) %>% 
  distinct() %>%
  left_join(syn_scores) %>% 
  spread(method, score_average) %>% 
  dplyr::select(pi, Bliss,    HSA,     Loewe,     ZIP) %>% 
  corrr::correlate(method = "spearman") %>% 
  corrr::stretch() %>% drop_na %>% 
  filter(x == "pi")
```


##delta_auc 

Now I just calculate the difference between AUCs of a query at its lowest and its highest concentration. 
```{r}
auc_syn_mod <- auc_syn %>% as.tibble() %>% 
  dplyr::select(drug, l_AUC_actual, line) %>% distinct() %>% 
  separate(drug, c("library", "drug"), sep = "_")

auc_delta <- auc_syn_mod %>% 
  filter(library != "L11DM") %>% distinct() %>%
  left_join(auc_syn_mod %>% filter(library == "L11DM") %>% 
              mutate(l_AUC_dmso = l_AUC_actual) %>% 
              dplyr::select(-library,  -l_AUC_actual) %>% distinct()) %>% 
  mutate(l_AUC_delta = l_AUC_actual - l_AUC_dmso) %>% 
  separate(library, c("query", "query_conc"), remove = FALSE, 5) 

auc_delta %>%
  ggplot(aes(l_AUC_delta)) +
  ggridges::geom_density_ridges(aes(x = l_AUC_delta, y = query_conc)) +
  facet_grid(~query ) + 
  theme_ridges() + 
  ggsave("ridge_auc.pdf", height = 3, width = 6)
```

```{r}
auc_delta %>% filter(query == "L11EV") %>% 
  arrange(desc(l_AUC_delta))
```

I now calculate a single delta AUC value for each combination by building the sum of all query concentrations. 

```{r}
auc_delta_sum <- auc_delta %>% 
  group_by(query, drug, line) %>% 
  summarise(s_l_AUC_delta = sum(l_AUC_delta),
            r_l_AUC_delta = abs(range(l_AUC_delta)[2]-range(l_AUC_delta)[1]))


auc_delta_sum %>% 
  ggplot(aes(s_l_AUC_delta)) +
  geom_density() + 
  facet_grid(~query ) + 
  theme_bw() + 
  ggsave("ridge_sauc.pdf", height = 3, width = 6)
```


#Define hits

For now I will continue with the established synergy scoring methods. I plot all tested Blocks that had a successful synergy calculation in every replciate and line.  
First I define BlockIDs which match these criteria.

```{r}
fb <- syn_scores %>%
  group_by(BlockID, method) %>%
  summarise(n = sum(is.na(score_average))) %>%
  filter(n > 0) %>%
  .$BlockID
```

Now I am interested in the correlation of synergy scoring methods.

```{r}
syn_scores %>% 
  filter(!BlockID %in% fb) %>% 
  dplyr::select(-score_sd) %>%
  spread(method, score_average) %>% 
  tidyr::unite(id, BlockID, line, Replicate, sep = "_") %>% 
    as.data.frame() %>% 
    column_to_rownames("id") %>%
  corrr::correlate(method = "spearman")
  
```

As it turns out there no measure can be dropped due to redundancy.  


I integrate delta_AUCs into the table.

```{r}
syn_scores <- syn_scores %>% 
  full_join(., auc_delta_sum %>% 
              rename(score_average = s_l_AUC_delta,
                     score_sd = r_l_AUC_delta) %>% 
              mutate(Replicate = 3,
                     method = "DeltaAUC") %>% 
              unite(BlockID, query, drug, sep = "_"), by = c("BlockID", "method", "Replicate", "line", "score_average", "score_sd"))
```

Next I am interested in the distribution of synergy scores. 

```{r}
syn_scores %>% 
  filter(!BlockID %in% fb) %>% 
  ggplot(aes(score_average, stat(count), fill = line)) + 
  geom_density(alpha = 0.7) + 
  theme_bw() + 
  scale_fill_manual(values = c("#A9A9A9", "#696969")) + 
  facet_grid( ~ method) + 
  ggsave("dist_synergy.pdf", width = 6, height = 3)
```

Before calculating a qq plot, I center and scale my data by line and method. 

```{r}
syn_scores <- syn_scores %>%
  group_by(line, method) %>% 
  mutate(mu = mean(score_average, na.rm = TRUE),
         sd = sd(score_average, na.rm = TRUE),
         sc_score = (score_average-mu)/sd)
```

```{r}
syn_scores %>% 
  separate(BlockID, c("query", "drug"), remove = FALSE, sep = "_") %>%
  mutate(query = if_else(query == "L11NA", "Napabucasin", 
                         if_else(query == "L11TR", "Trametinib", "Everolimus"))) %>%
  #filter(!BlockID %in% fb) %>% 
  ggplot(aes(sc_score, stat(count), fill = line)) + 
  geom_density(alpha = 0.7) + 
  theme_bw() + 
  scale_fill_manual(values = c("#A9A9A9", "#696969")) + 
  facet_grid(query ~ method) + 
  ggsave("dist_scaled_synergy.pdf", width = 6, height = 3)
```


I will plot the qq plot of summarized synergy scores.
First I create an overview plot of both tested queries with each synergy method seperately.
 
```{r}
tidy_qqplot <- function(syn_scores_red){
g <- syn_scores_red %>%
  ggplot(aes(sample = score_average, label = BlockID)) + 
  stat_qq(show.legend = TRUE) + 
  stat_qq_line() + 
  #facet_grid(~method) + 
  theme_classic()

build <- ggplot_build(g)$data[[1]] 

build$BlockID<-syn_scores_red$BlockID[order(syn_scores_red$score_average)]
return(build)
}

syn_scores_qq <- syn_scores %>%
  filter(!BlockID %in% fb) %>% 
  filter(method != "DeltaAUC") %>%
  #I overwrite my variable name to match the function
  mutate(score_average = sc_score) %>%
  separate(BlockID, c("query", "drug"), remove = FALSE, sep = "_") %>%
  #filter(method == "ZIP") %>%
  #filter(grepl(pattern = "L11NA", BlockID)) %>%
  group_by(BlockID, method, query, drug) %>% 
  summarise(score_average = mean(score_average)) %>% 
    ungroup() %>% 
  
    group_by(query, method) %>% 
    do(tidy_qqplot(.)) %>% 
  separate(BlockID, c("b_query", "b_drug"), remove = FALSE, sep = "_") %>% 
  ungroup() %>%
  mutate(query = if_else(query == "L11NA", "Napabucasin", 
                         if_else(query == "L11TR", "Trametinib", "Everolimus")))

syn_scores_qq %>% 

  ggplot(aes(theoretical,sample,label=b_drug)) +
  geom_point()+ 
  geom_smooth(data = syn_scores_qq %>% filter(abs(theoretical) < 1.45), method = "lm", fullrange = TRUE, se = FALSE, color = "black", size = .5) +
  geom_text_repel(data = syn_scores_qq %>% group_by(query, method) %>% do(tail(., 5)), 
                  size = 2, segment.size = 0.3,
                  point.padding = .5) +
  theme_bw() +
  facet_grid(method ~ query) +
  geom_rug(sides = "l", size = 0.2) +
  labs(y = "measured synergy score",
       x = "theoretical distribution" ) + 
  ggsave("qq_overview.pdf", width = 5, height = 9) 

#syn_scores_qq %>% group_by(query, method) %>% do(tail(., 5))
```

I prepare a qqplot including AUC based synergy scoring systems.

```{r}
syn_scores_qq <- syn_scores %>%
  filter(!BlockID %in% fb) %>% 
  #filter(method != "DeltaAUC") %>%
  #I overwrite my variable name to match the function
  mutate(score_average = sc_score) %>%
  separate(BlockID, c("query", "drug"), remove = FALSE, sep = "_") %>%
  #filter(method == "ZIP") %>%
  #filter(grepl(pattern = "L11NA", BlockID)) %>%
  group_by(BlockID, method, query, drug) %>% 
  summarise(score_average = mean(score_average)) %>% 
    ungroup() %>% 
  
    group_by(query, method) %>% 
    do(tidy_qqplot(.)) %>% 
  separate(BlockID, c("b_query", "b_drug"), remove = FALSE, sep = "_") %>% 
  ungroup() %>%
  mutate(query = if_else(query == "L11NA", "Napabucasin", 
                         if_else(query == "L11TR", "Trametinib", "Everolimus")))

syn_scores_qq %>% 
  
  ggplot(aes(theoretical,sample,label=b_drug)) +
  geom_point()+ 
  geom_smooth(data = syn_scores_qq %>% filter(abs(theoretical) < 1.45), method = "lm", fullrange = TRUE, se = FALSE, color = "black", size = .5) +
  geom_text_repel(data = syn_scores_qq %>% group_by(query, method) %>% do(tail(., 5)), 
                  size = 2, segment.size = 0.3,
                  point.padding = .5) +
  theme_bw() +
  facet_grid(method ~ query) +
  geom_rug(sides = "l", size = 0.2) +
  labs(y = "measured synergy score",
       x = "theoretical distribution" ) + 
  ggsave("qq_overview_plusauc.pdf", width = 5, height = 9)
```

The AUC based method does not seem to correspond well with other methods. Consequently, I remove this method from further analysis, as it does not seem to overlap with other synergy scores. 

##Line-specific effect

First, I define a new set of filtered drugs. 

```{r}
fb_select <- syn_scores %>%
  filter(line != "D027T01") %>%
  group_by(BlockID, method) %>%
  summarise(n = sum(is.na(score_average))) %>%
  filter(n > 0) %>%
  .$BlockID
```

I now look at line-specfic effects of drug synergy.

```{r}
syn_scores_qq <- syn_scores %>%
  filter(!BlockID %in% fb) %>% 
  filter(method != "DeltaAUC") %>%
  #I overwrite my variable name to match the function
  mutate(score_average = sc_score) %>%
  separate(BlockID, c("query", "drug"), remove = FALSE, sep = "_") %>%
  #filter(method == "ZIP") %>%
  #filter(grepl(pattern = "L11NA", BlockID)) %>%
  group_by(BlockID, method, query, drug, line) %>% 
  summarise(score_average = mean(score_average)) %>% 
    ungroup() %>% 
  unite(id, c("query", "line")) %>%
    group_by(method, id) %>% 
    do(tidy_qqplot(.)) %>% 
  separate(BlockID, c("b_query", "b_drug"), remove = FALSE, sep = "_") %>% 
  ungroup() %>%
  mutate(query = if_else(b_query == "L11NA", "Napabucasin", 
                         if_else(b_query == "L11TR", "Trametinib", "Everolimus")))

syn_scores_qq %>% 
  ggplot(aes(theoretical,sample,label=b_drug)) +
  geom_point()+ 
  geom_smooth(data = syn_scores_qq %>% filter(abs(theoretical) < 1.45), method = "lm", fullrange = TRUE, se = FALSE, color = "black", size = .5) +
  geom_text_repel(data = syn_scores_qq %>% group_by(id, method) %>% do(tail(., 4)), 
                  size = 2, segment.size = 0.3,
                  point.padding = .5) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  facet_grid(method ~ id) +
  geom_hline(yintercept = 2, linetype="dashed") +
  geom_rug(sides = "l", size = 0.2) +
  labs(y = "measured synergy score",
       x = "theoretical distribution" ) + 
  ggsave("qq_overview_line.pdf", width = 5, height = 5) 
```


I now want to take a look at the little Eveloimus data I have. 

```{r}
syn_scores_qq <- syn_scores %>%
  #filter(!BlockID %in% fb) %>% 
  #filter(method != "DeltaAUC") %>%
  #I overwrite my variable name to match the function
  mutate(score_average = sc_score) %>%
  separate(BlockID, c("query", "drug"), remove = FALSE, sep = "_") %>%
  
  #filter(query == "L11EV") %>%
  dplyr::select(-score_sd, -mu, - sd, -sc_score) %>%
  drop_na() %>%
  #filter(method == "ZIP") %>%
  #filter(grepl(pattern = "L11NA", BlockID)) %>%
  group_by(BlockID, method, query, drug, line) %>% 
  summarise(score_average = mean(score_average)) %>% 
    ungroup() %>% 
  unite(id, c("query", "line")) %>%
    group_by(method, id) %>% 
    do(tidy_qqplot(.)) %>% 
  separate(BlockID, c("b_query", "b_drug"), remove = FALSE, sep = "_") %>% 
  ungroup() %>%
  mutate(query = if_else(b_query == "L11NA", "Napabucasin", 
                         if_else(b_query == "L11TR", "Trametinib", "Everolimus")))

syn_scores_qq %>% 
  ggplot(aes(theoretical,sample,label=b_drug)) +
  geom_point()+ 
  geom_smooth(data = syn_scores_qq %>% filter(abs(theoretical) < 1.45), method = "lm", fullrange = TRUE, se = FALSE, color = "black", size = .5) +
  geom_text_repel(data = syn_scores_qq %>% group_by(id, method) %>% do(tail(., 4)), 
                  size = 2, segment.size = 0.3,
                  point.padding = .5) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  facet_grid(method ~ id) +
  geom_hline(yintercept = 2, linetype="dashed") +
  geom_rug(sides = "l", size = 0.2) +
  labs(y = "measured synergy score",
       x = "theoretical distribution" ) + 
  ggsave("qq_overview_line_all_drugs.pdf", width = 7.5, height = 7.5) 
```


Next I spike in my TAS data and compare it in light of these results. 

```{r}
load("tas_syn_complete.Rdata")

tas_syn <- tas_syn %>% mutate( line = case_when(line == "07" ~ "D007T01",
                      line == "19" ~ "D019T01",
                      line == "27" ~ "D027T01"
                      )) %>% 
  group_by(line, method) %>% 
  mutate(mu = mean(score_average, na.rm = TRUE),
         sd = sd(score_average, na.rm = TRUE),
         sc_score = (score_average-mu)/sd)

syn_scores_combined <- rbind(syn_scores, tas_syn)
```

Now I plot all this data. 

```{r}
syn_scores_qq <- syn_scores_combined %>%
  #filter(!BlockID %in% fb) %>% 
  #filter(method != "DeltaAUC") %>%
  #I overwrite my variable name to match the function
  mutate(score_average = sc_score) %>%
  separate(BlockID, c("query", "drug"), remove = FALSE, sep = "_") %>%
  
  #filter(query == "L11EV") %>%
  dplyr::select(-score_sd, -mu, - sd, -sc_score) %>%
  drop_na() %>%
  #filter(method == "ZIP") %>%
  #filter(grepl(pattern = "L11NA", BlockID)) %>%
  group_by(BlockID, method, query, drug, line) %>% 
  summarise(score_average = mean(score_average)) %>% 
    ungroup() %>% 
  unite(id, c("query", "line")) %>%
    group_by(method, id) %>% 
    do(tidy_qqplot(.)) %>% 
  separate(BlockID, c("b_query", "b_drug"), remove = FALSE, sep = "_") %>% 
  ungroup() %>%
  mutate(query = case_when(b_query == "L11NA" ~ "Napabucasin",
                      b_query == "L11TR" ~ "Trametinib",
                      b_query == "L11EV" ~ "Everolimus",
                      b_query == "TAS-102" ~ "TAS-102"))

syn_scores_qq %>% 
  ggplot(aes(theoretical,sample,label=b_drug)) +
  geom_point()+ 
  geom_smooth(data = syn_scores_qq %>% filter(abs(theoretical) < 1.45), method = "lm", fullrange = TRUE, se = FALSE, color = "black", size = .5) +
  geom_text_repel(data = syn_scores_qq %>% group_by(id, method) %>% do(tail(., 4)), 
                  size = 2, segment.size = 0.3,
                  point.padding = .5) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  facet_grid(method ~ id) +
  geom_hline(yintercept = 2, linetype="dashed") +
  geom_rug(sides = "l", size = 0.2) +
  labs(y = "measured synergy score",
       x = "theoretical distribution" ) + 
  ggsave("qq_overview_line_all_drugs_tas.pdf", width = 9.5, height = 7.5) 
```

I create a shortlist of compounds with a synergy of z > 2.

```{r}
syn_scores_combined %>% 
  filter(sc_score > 2) %>% 
  dplyr::select(BlockID:line, sc_score) %>% 
  group_by(BlockID) %>%
  summarise(n= n()) %>% 
  arrange(desc(n)) %>% 
  write.csv("top_synergy_pairs.csv")
  
```

I define a function to plot dose response curves for the highest and lowest query concentration of a given query compound.

```{r}
coi <- c("YM155", "PRI-724", "Sunitinib")

tidy_drc_fit <- function(df){  
  # predictions and confidence intervals.
  org.fits <- expand.grid(conc=exp(seq(log(10), log(0.016), length=1000)))
  
  fits <- drm(data = df, pc_norm ~ conc, fct=LL.4(), na.action = na.omit) %>%
  predict(., newdata = org.fits, interval = "confidence")
  
  org.fits %>%
    mutate(p = fits[,1],
           pmin = fits[,2],
           pmax = fits[,3],
           line = df$line %>% unique(),
           drug = df$drug %>% unique(),
           Row = df$Row %>% unique()) %>%
    full_join(df) %>%
  return(.)
}

library(PharmacoGx) #cite
library(growthcurve) #cite
library(drc)

tmp_gr_all_formatted <- syn_table %>% 
  filter(DrugRow == "L11EV") %>% 
  distinct() %>%
  as.tibble() %>% 
  #filter(DrugCol == "YM155") %>% 
  filter(Row %in% c(1,4)) %>%
  unite(run, Row, Replicate, remove = FALSE) %>%
  mutate(Row = factor(Row)) %>%
  mutate(conc = ConcCol %>% as.numeric(),
         pc_norm = Response,
         line = line,
         drug = DrugCol,
         GR = Response) %>%
  group_by(drug, ConcCol, Row, line) %>%
     dplyr::mutate(n = n(),
                      GR_sd = abs(range(GR)[1] - range(GR)[2])/2,
                      GR = mean(GR, na.rm = TRUE))

tmp_gr_all_fit <- tmp_gr_all_formatted %>%
  dplyr::select(line, drug, pc_norm, conc, Col, Row) %>%
  filter(drug %in% coi) %>%
  group_by(drug, line, Row) %>%
  do(., tidy_drc_fit(.))

plot_dose_response_fit <- function(coi, query){
  tmp_gr_all_fit %>%
  left_join(tmp_gr_all_formatted) %>%
  dplyr::filter(drug %in% coi) %>%
  ggplot(aes(conc, GR, color = Row, group = Row)) + 
  geom_point(size = 2.5) + 
  #coord_trans(x="log") +
  theme_classic() +
  geom_errorbar(data = tmp_gr_all_formatted %>%
                  dplyr::filter(drug %in% coi),
                aes(x=conc, ymin=GR-GR_sd, ymax=GR+GR_sd, group = line),
                alpha=1, color = "black", width = 0.05) +
  geom_hline(yintercept = 100) + 
  geom_hline(yintercept = 0) + 
  geom_line(aes(x=conc, y=p)) +
  xlab("log10 concentration [uM]") + 
  ylab("Viability") +
  ggtitle(query) +
  #scale_y_continuous(limits = c(0,120)) +
  scale_x_log10() +
  facet_grid(drug ~ line) +
  scale_color_manual(values=rev(c("#999999", "#777777", "#555555", "#333333", "#111111")[c(1,5)])) +
  #theme(legend.position="none") +
  ggsave(paste0(query, "_top_drugs.pdf"), width = 6, height = 5)
}

plot_dose_response_fit(coi, "Everolimus")
```

For reference I plot the strongest drugs from Trametintib

```{r}
coi <- c("Docetaxel", "Napabucasin", "Volasertib")

tmp_gr_all_formatted <- syn_table %>% 
  filter(DrugRow == "L11TR") %>% 
  distinct() %>%
  as.tibble() %>% 
  #filter(DrugCol == "YM155") %>% 
  filter(Row %in% c(1,4)) %>%
  unite(run, Row, Replicate, remove = FALSE) %>%
  mutate(Row = factor(Row)) %>%
  mutate(conc = ConcCol %>% as.numeric(),
         pc_norm = Response,
         line = line,
         drug = DrugCol,
         GR = Response) %>%
  group_by(drug, ConcCol, Row, line) %>%
     dplyr::mutate(n = n(),
                      GR_sd = abs(range(GR)[1] - range(GR)[2])/2,
                      GR = mean(GR, na.rm = TRUE))

tmp_gr_all_fit <- tmp_gr_all_formatted %>%
  dplyr::select(line, drug, pc_norm, conc, Col, Row) %>%
  filter(drug %in% coi) %>%
  group_by(drug, line, Row) %>%
  do(., tidy_drc_fit(.))

plot_dose_response_fit <- function(coi, query){
  tmp_gr_all_fit %>%
  left_join(tmp_gr_all_formatted) %>%
  dplyr::filter(drug %in% coi) %>%
  ggplot(aes(conc, GR, color = Row, group = Row)) + 
  geom_point(size = 2.5) + 
  #coord_trans(x="log") +
  theme_classic() +
  geom_errorbar(data = tmp_gr_all_formatted %>%
                  dplyr::filter(drug %in% coi),
                aes(x=conc, ymin=GR-GR_sd, ymax=GR+GR_sd, group = line),
                alpha=1, color = "black", width = 0.05) +
  geom_hline(yintercept = 100) + 
  geom_hline(yintercept = 0) + 
  geom_line(aes(x=conc, y=p)) +
  xlab("log10 concentration [uM]") + 
  ylab("Viability") +
  ggtitle(query) +
  #scale_y_continuous(limits = c(0,120)) +
  scale_x_log10() +
  facet_grid(drug ~ line) +
  scale_color_manual(values=rev(c("#999999", "#777777", "#555555", "#333333", "#111111")[c(1,5)])) +
  #theme(legend.position="none") +
  ggsave(paste0(query, "_top_drugs.pdf"), width = 6, height = 5)
}

plot_dose_response_fit(coi, "Trametinib")
```

```{r}
coi <- c("Trametinib", "Sunitinib", "Gemcitabine")

tmp_gr_all_formatted <- syn_table %>% 
  filter(DrugRow == "L11NA") %>% 
  distinct() %>%
  as.tibble() %>% 
  #filter(DrugCol == "YM155") %>% 
  filter(Row %in% c(1,4)) %>%
  unite(run, Row, Replicate, remove = FALSE) %>%
  mutate(Row = factor(Row)) %>%
  mutate(conc = ConcCol %>% as.numeric(),
         pc_norm = Response,
         line = line,
         drug = DrugCol,
         GR = Response) %>%
  group_by(drug, ConcCol, Row, line) %>%
     dplyr::mutate(n = n(),
                      GR_sd = abs(range(GR)[1] - range(GR)[2])/2,
                      GR = mean(GR, na.rm = TRUE))

tmp_gr_all_fit <- tmp_gr_all_formatted %>%
  dplyr::select(line, drug, pc_norm, conc, Col, Row) %>%
  filter(drug %in% coi) %>%
  group_by(drug, line, Row) %>%
  do(., tidy_drc_fit(.))

plot_dose_response_fit <- function(coi, query){
  tmp_gr_all_fit %>%
  left_join(tmp_gr_all_formatted) %>%
  dplyr::filter(drug %in% coi) %>%
  ggplot(aes(conc, GR, color = Row, group = Row)) + 
  geom_point(size = 2.5) + 
  #coord_trans(x="log") +
  theme_classic() +
  geom_errorbar(data = tmp_gr_all_formatted %>%
                  dplyr::filter(drug %in% coi),
                aes(x=conc, ymin=GR-GR_sd, ymax=GR+GR_sd, group = line),
                alpha=1, color = "black", width = 0.05) +
  geom_hline(yintercept = 100) + 
  geom_hline(yintercept = 0) + 
  geom_line(aes(x=conc, y=p)) +
  xlab("log10 concentration [uM]") + 
  ylab("Viability") +
  ggtitle(query) +
  #scale_y_continuous(limits = c(0,120)) +
  scale_x_log10() +
  facet_grid(drug ~ line) +
  scale_color_manual(values=rev(c("#999999", "#777777", "#555555", "#333333", "#111111")[c(1,5)])) +
  #theme(legend.position="none") +
  ggsave(paste0(query, "_top_drugs.pdf"), width = 6, height = 5)
}

plot_dose_response_fit(coi, "Napabucasin")
```



#Final list: 


Trametinib:
Docetaxel
Vinblastin
Volasertib
Taselisib

Napabucasin:
YM155
Vistusertib
Sunitinib


